## Идемпотентость и коммутативность API в HTTP и очередях

Цель:
В этом ДЗ вы создадите сервис "Заказ" (или научитесь использовать сервис из прошлого занятия) и для одного из его методов, например, "создание заказа" сделаете идемпотетным.

Описание/Пошаговая инструкция выполнения домашнего задания:
На выходе должно быть:
0. описание того, какой паттерн для реализации идемпотентности использовался
1. команда установки приложения (из helm-а или из манифестов). Обязательно указать в каком namespace нужно устанавливать и команду создания namespace, если это важно для сервиса.
2. тесты в postman

## Архитектура сервиса

В сервис "Заказ" добавлена идемпотентость на размещение заказа.

Так как у нас в сервисе заказ размещаются на покупку "Подписки" на какой-либо сервис.

Поэтому для одного пользователя может быть куплена только одна подписка определенного вида.

### Поэтому при размещении заказа, ключем идемпотентости является UserId + SubscriptionId

### Как происходит проверка ключа идемпотентости
Идем в бд и смотреть есть ли уже оплаченная подписка, и данные о 
подписке сохраняется в кеш на 5 минут.

Кеш будет инвалидирован по TTL, либо в момент покупки новой версии подписки

### На данный момент в сервисе поддерживается три вида подписок
1. Daily - Подписка с ежедневной оплатой. Стоимость 10
2. Monthly - Подписка с ежемесячной оплатой. Стоимость 95
3. Yearly - Подписка с ежегодной оплатой. Стоимость 1200

## Бизнес логика

### Сценарии:
#### 1. Повышения
Если уже у пользователя оформлена "Daily" или "Monthly" и пользователь желает приобрести
более дорогую/долгую подписку, например "Monthly" или "Yearly"

То текущая подпиcка становится не активная после окончания ее срока, а 
дата начала действия следующей подписки, начнется 
на следующий день после окончания предыдущей подписки

#### 2. Понижение с "Yearly" до "Monthly" или с "Monthly" до "Daily"
Если уже у пользователя оформлена подписка "Yearly" или  "Monthly" и пользователь желает
понизить подписку "Yearly" до "Monthly" или с "Monthly" до "Daily", то сумма уже 
оплаченной подписки возвращается в кошелек пользователя.

Сумма рассчитывается равномерно пройденным дням с даты начала действия подписки.

## Для начала стоит добавить кафку в наш кластер
```kubectl apply -f helm/kafka```

#### Топики создавать не нужно в ручную, сервис их сам добавит

Также вместе с kafka поднимается kafka-ui для наглядного отображения сообщений в очереди

чтобы получить доступ откроем порт для kafka-ui

Команда

```kubectl port-forward service/kafka-ui 8080```
## Команда для запуска сервиса без сбора метрик

```helm upgrade --install lotus ./lotus --values lotus/values.yaml --set metrics.serviceMonitor.enabled=false```

### стартуем тунель чтобы подключаться к нашему сервису локально

```minikube tunnel```

# Сценарии тестирования
## 1. Покупка подписки дважды
1. Пользователь регистрируется
```
POST /profile/register
```
Проверки:
- Ожидаем 201 статус
- копируем емейл пользоваталя в переменную Postman
2. Пользователь авторизуется
```
POST /profile/login
```
Проверки:
- использую емейл и пароль с предыдущего шага
- Ожидаем 200 статус
- копируем авторизационный токен пользователя в переменную Postman
3. Пользователь пополняет баланс
```
POST /billing/add-money?money=1000
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 200 статус
4. Пользователь оформляет заказ
```
POST /order/place?idSubscription=1
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 202 статус
- копируем номер заказа {orderId} переменную Postman
- 
5. Пользователь оформляет заказ второй раз на ту же подписку
```
POST /order/place?idSubscription=1
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 202 статус
- проверяем номер заказа {orderId} из переменной Postman и сверяем с тем orderId, 
который вернулся при создании этого заказ. Они должны совпадать

## 2. Покупка новой подписки 
1. Пользователь регистрируется
```
POST /profile/register
```
Проверки:
- Ожидаем 201 статус
- копируем емейл пользователя в переменную Postman
2. Пользователь авторизуется
```
POST /profile/login
```
Проверки:
- использую емейл и пароль с предыдущего шага
- Ожидаем 200 статус
- копируем авторизационный токен пользователя в переменную Postman
3. Пользователь пополняет баланс
```
POST /billing/add-money?money=1000
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 200 статус
4. Пользователь оформляет заказ
```
POST /order/place?idSubscription=1
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 202 статус
- копируем номер заказа {orderId} переменную Postman
-
5. Пользователь оформляет заказ на другую подписку
```
POST /order/place?idSubscription=2
```
Для запроса используем токен, который был получен на 2-ом шаге

Проверки:
- Ожидаем 202 статус
- проверяем номер заказа {orderId} из переменной Postman и сверяем с тем orderId,
  который вернулся при создании этого заказ. Они должны отличаться


Postman коллекция в этом папке
Запустить коллекцию командой

```
newman run OrderIdempotency.postman_collection.json --env-var "lotus=http://arch.homework"
```
Результат запуска коллекции
```
```